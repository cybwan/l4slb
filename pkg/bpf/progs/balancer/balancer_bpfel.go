// Code generated by bpf2go; DO NOT EDIT.
//go:build 386 || amd64 || amd64p32 || arm || arm64 || mips64le || mips64p32le || mipsle || ppc64le || riscv64
// +build 386 amd64 amd64p32 arm arm64 mips64le mips64p32le mipsle ppc64le riscv64

package balancer

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

type balancerCtlValue struct{ Value uint64 }

type balancerFlowKey struct {
	Src   uint32
	_     [12]byte
	Dst   uint32
	_     [12]byte
	Ports uint32
	Proto uint8
	_     [3]byte
}

type balancerLbQuicPacketsStats struct {
	ChRouted              uint64
	CidInitial            uint64
	CidInvalidServerId    uint64
	CidRouted             uint64
	CidUnknownRealDropped uint64
	CidV0                 uint64
	CidV1                 uint64
	CidV2                 uint64
	CidV3                 uint64
}

type balancerLbStats struct {
	V1 uint64
	V2 uint64
}

type balancerRealDefinition struct {
	Dst   uint32
	_     [12]byte
	Flags uint8
	_     [3]byte
}

type balancerRealPosLru struct {
	Pos   uint32
	_     [4]byte
	Atime uint64
}

type balancerV4LpmKey struct {
	Prefixlen uint32
	Addr      uint32
}

type balancerV6LpmKey struct {
	Prefixlen uint32
	Addr      [4]uint32
}

type balancerVipDefinition struct {
	Vip   uint32
	_     [12]byte
	Port  uint16
	Proto uint8
	_     [1]byte
}

type balancerVipMeta struct {
	Flags  uint32
	VipNum uint32
}

// loadBalancer returns the embedded CollectionSpec for balancer.
func loadBalancer() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_BalancerBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load balancer: %w", err)
	}

	return spec, err
}

// loadBalancerObjects loads balancer and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*balancerObjects
//	*balancerPrograms
//	*balancerMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func loadBalancerObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := loadBalancer()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// balancerSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type balancerSpecs struct {
	balancerProgramSpecs
	balancerMapSpecs
}

// balancerSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type balancerProgramSpecs struct {
	BalancerIngress *ebpf.ProgramSpec `ebpf:"balancer_ingress"`
}

// balancerMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type balancerMapSpecs struct {
	ChRings             *ebpf.MapSpec `ebpf:"ch_rings"`
	CtlArray            *ebpf.MapSpec `ebpf:"ctl_array"`
	FallbackCache       *ebpf.MapSpec `ebpf:"fallback_cache"`
	FallbackGlru        *ebpf.MapSpec `ebpf:"fallback_glru"`
	GlobalLruMaps       *ebpf.MapSpec `ebpf:"global_lru_maps"`
	LpmSrcV4            *ebpf.MapSpec `ebpf:"lpm_src_v4"`
	LpmSrcV6            *ebpf.MapSpec `ebpf:"lpm_src_v6"`
	LruMapping          *ebpf.MapSpec `ebpf:"lru_mapping"`
	LruMissStats        *ebpf.MapSpec `ebpf:"lru_miss_stats"`
	LruMissStatsVip     *ebpf.MapSpec `ebpf:"lru_miss_stats_vip"`
	QuicPacketsStatsMap *ebpf.MapSpec `ebpf:"quic_packets_stats_map"`
	Reals               *ebpf.MapSpec `ebpf:"reals"`
	RealsStats          *ebpf.MapSpec `ebpf:"reals_stats"`
	ServerIdMap         *ebpf.MapSpec `ebpf:"server_id_map"`
	Stats               *ebpf.MapSpec `ebpf:"stats"`
	VipMap              *ebpf.MapSpec `ebpf:"vip_map"`
}

// balancerObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadBalancerObjects or ebpf.CollectionSpec.LoadAndAssign.
type balancerObjects struct {
	balancerPrograms
	balancerMaps
}

func (o *balancerObjects) Close() error {
	return _BalancerClose(
		&o.balancerPrograms,
		&o.balancerMaps,
	)
}

// balancerMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to loadBalancerObjects or ebpf.CollectionSpec.LoadAndAssign.
type balancerMaps struct {
	ChRings             *ebpf.Map `ebpf:"ch_rings"`
	CtlArray            *ebpf.Map `ebpf:"ctl_array"`
	FallbackCache       *ebpf.Map `ebpf:"fallback_cache"`
	FallbackGlru        *ebpf.Map `ebpf:"fallback_glru"`
	GlobalLruMaps       *ebpf.Map `ebpf:"global_lru_maps"`
	LpmSrcV4            *ebpf.Map `ebpf:"lpm_src_v4"`
	LpmSrcV6            *ebpf.Map `ebpf:"lpm_src_v6"`
	LruMapping          *ebpf.Map `ebpf:"lru_mapping"`
	LruMissStats        *ebpf.Map `ebpf:"lru_miss_stats"`
	LruMissStatsVip     *ebpf.Map `ebpf:"lru_miss_stats_vip"`
	QuicPacketsStatsMap *ebpf.Map `ebpf:"quic_packets_stats_map"`
	Reals               *ebpf.Map `ebpf:"reals"`
	RealsStats          *ebpf.Map `ebpf:"reals_stats"`
	ServerIdMap         *ebpf.Map `ebpf:"server_id_map"`
	Stats               *ebpf.Map `ebpf:"stats"`
	VipMap              *ebpf.Map `ebpf:"vip_map"`
}

func (m *balancerMaps) Close() error {
	return _BalancerClose(
		m.ChRings,
		m.CtlArray,
		m.FallbackCache,
		m.FallbackGlru,
		m.GlobalLruMaps,
		m.LpmSrcV4,
		m.LpmSrcV6,
		m.LruMapping,
		m.LruMissStats,
		m.LruMissStatsVip,
		m.QuicPacketsStatsMap,
		m.Reals,
		m.RealsStats,
		m.ServerIdMap,
		m.Stats,
		m.VipMap,
	)
}

// balancerPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to loadBalancerObjects or ebpf.CollectionSpec.LoadAndAssign.
type balancerPrograms struct {
	BalancerIngress *ebpf.Program `ebpf:"balancer_ingress"`
}

func (p *balancerPrograms) Close() error {
	return _BalancerClose(
		p.BalancerIngress,
	)
}

func _BalancerClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed balancer_bpfel.o
var _BalancerBytes []byte
